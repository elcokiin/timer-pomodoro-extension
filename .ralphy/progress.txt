# Ralphy Progress Log

## 2026-02-15: Phase 1 - Task 1: Initialize Vite + React + TypeScript project
- Scaffolded Vite + React + TypeScript project using `create-vite` with `react-ts` template
- Adapted project structure for Chrome Extension compatibility:
  - Created `src/background/`, `src/components/`, `src/hooks/`, `src/types/` directories
  - Updated `index.html` as popup entry point (400x500px body dimensions)
  - Cleaned up boilerplate (removed default Vite/React demo code)
- Added Chrome Extension dev dependencies: `@types/chrome`
- Added test infrastructure: `vitest`, `@testing-library/react`, `@testing-library/jest-dom`, `jsdom`
- Configured Vitest in `vite.config.ts` with jsdom environment
- Added `chrome` type to `tsconfig.app.json` for Chrome API type support
- Updated `package.json` name to `pomodoro-task-extension`, added `test` and `test:watch` scripts
- Wrote 12 tests (App component rendering + project structure validation), all passing
- Linting passes cleanly

## 2026-02-15: Phase 1 - Task 2: Configure Tailwind CSS and install shadcn/ui CLI
- Installed Tailwind CSS v4 (`tailwindcss`, `@tailwindcss/vite`) as dev dependencies
- Configured `@tailwindcss/vite` plugin in `vite.config.ts` for Tailwind v4 CSS-first approach
- Installed shadcn/ui core dependencies: `class-variance-authority`, `clsx`, `tailwind-merge`, `lucide-react`, `tw-animate-css`, `shadcn`
- Ran `npx shadcn@latest init --defaults` to scaffold shadcn/ui configuration:
  - Generated `components.json` with New York style, Vite framework, Tailwind v4
  - Updated `src/index.css` with `@import "tailwindcss"`, `@import "tw-animate-css"`, `@import "shadcn/tailwind.css"`, full CSS variable theming (oklch colors), and `@theme inline` block
- Created `src/lib/utils.ts` with the `cn()` utility function (clsx + tailwind-merge)
- Added `@/*` path alias in `tsconfig.app.json`, `tsconfig.json`, and `vite.config.ts` for shadcn imports
- Created missing source directories (`src/background/`, `src/components/`, `src/hooks/`, `src/types/`) with `.gitkeep` files
- Wrote 12 new tests validating Tailwind + shadcn/ui configuration, all passing (24 total tests)
- Linting passes cleanly

## 2026-02-15: Phase 1 - Task 4: Create manifest.json (Manifest V3)
- Created `public/manifest.json` with Manifest V3 configuration:
  - `manifest_version: 3`
  - Permissions: `alarms`, `storage`, `notifications`, `activeTab`
  - Action: `default_popup` pointing to `index.html`, with `default_title`
  - Background: service worker with `type: "module"` for ES module support
  - Icons: 16x16, 48x48, 128x128 PNG placeholder icons
- Created `public/icons/` directory with placeholder PNG icons (icon-16.png, icon-48.png, icon-128.png)
- Also marked Phase 1 - Task 3 (shadcn components) as complete in PRD (was already implemented in prior session)
- Wrote 20 new tests validating manifest.json structure, permissions, action, background, and icons (75 total tests)
- All 75 tests passing
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 2 - Task 1: Create src/background.ts with timer logic using chrome.alarms
- Created `src/background/index.ts` as the background service worker entry point
- Implemented core timer logic using `chrome.alarms` API:
  - `TimerStorageState` interface: duration, timeLeft, isRunning, startTime, mode (work/break)
  - `DEFAULT_TIMER_STATE`: 25-minute work timer, not running, null startTime
  - `getTimerState()`: reads timer state from `chrome.storage.local`, returns defaults if empty
  - `setTimerState()`: persists timer state to `chrome.storage.local`
  - `computeTimeLeft()`: calculates real-time remaining seconds using elapsed time from startTime
  - `startTimer()`: sets isRunning, records startTime, creates chrome alarm with correct delay and 1-minute period
  - `pauseTimer()`: computes remaining time, stops timer, clears chrome alarm
  - `resetTimer()`: resets timeLeft to duration (or custom duration), stops timer, clears alarm
  - `handleAlarm()`: on alarm fire, checks remaining time; finishes timer if zero, updates stored state if still running
- Registered `handleAlarm` as `chrome.alarms.onAlarm` listener at module level
- Wrote 47 tests covering:
  - Module structure (8 exports verified)
  - DEFAULT_TIMER_STATE values (5 tests)
  - getTimerState/setTimerState storage interaction (5 tests)
  - computeTimeLeft pure logic (4 tests: not running, null startTime, elapsed computation, floor at zero)
  - startTimer behavior (7 tests: sets running, records timestamp, creates alarm, saves state, idempotent, guards zero timeLeft, alarm delay)
  - pauseTimer behavior (5 tests: stops running, clears alarm, nulls startTime, preserves remaining time, no-op if not running)
  - resetTimer behavior (6 tests: stops running, resets timeLeft, clears alarm, nulls startTime, custom duration, default duration)
  - handleAlarm behavior (5 tests: ignores other alarms, no-op if not running, finishes at zero, clears alarm on finish, updates mid-run)
  - Listener registration (2 tests: addListener called, function passed)
- All 122 tests passing (47 new + 75 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 2 - Task 2: Implement chrome.storage.local to persist timer state
- Added `restoreTimerState()` function to `src/background/index.ts`:
  - Runs automatically on service worker startup to ensure persistence across Chrome service worker restarts
  - Reads persisted state from `chrome.storage.local` and checks if timer was running
  - If timer expired while service worker was inactive: marks timer as finished (isRunning=false, timeLeft=0), persists the finished state
  - If timer still has remaining time: recalculates `timeLeft` based on elapsed time since `startTime`, resets `startTime` to `Date.now()`, re-creates the chrome alarm with correct delay, persists the restored state
  - Preserves `mode` and `duration` during restoration
  - No-ops gracefully when timer is not running or `startTime` is null
- Called `restoreTimerState()` at module level after listener registration to ensure persistence on every service worker restart
- Wrote 14 new tests covering `restoreTimerState()`:
  - Export existence, default state return, not-running state passthrough, null startTime guard
  - Timer expired while inactive: finishes timer, persists finished state, does not create alarm
  - Timer still running: re-creates alarm, recalculates timeLeft, resets startTime, sets correct alarm delay, persists restored state
  - Preserves mode and duration during restore
- All 136 tests passing (14 new + 122 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 2 - Task 3: Setup chrome.notifications alert when countdown reaches zero
- Added `showTimerNotification()` function to `src/background/index.ts`:
  - Accepts `mode` parameter ('work' | 'break') to customize notification content
  - Work mode: title "Work session complete!", message "Great job! Time to take a break."
  - Break mode: title "Break is over!", message "Break finished. Ready to focus again?"
  - Uses `chrome.notifications.create()` with type 'basic', icon 'icons/icon-128.png', priority 2
  - Uses a consistent notification ID (`pomodoro-timer-finished`) to replace previous notifications
- Integrated notification into `handleAlarm()`: triggers `showTimerNotification(state.mode)` when timer reaches zero
- Integrated notification into `restoreTimerState()`: triggers notification when timer expired while service worker was inactive
- Added `NOTIFICATION_ID` constant for consistent notification identification
- Wrote 16 new tests covering:
  - showTimerNotification: export, chrome.notifications.create call, 'basic' type, icon URL, notification ID, work title, break title, work message, break message, priority 2
  - handleAlarm notification integration: triggers notification on finish, work-mode notification title, break-mode notification title, no notification when still running
  - restoreTimerState notification integration: triggers notification on expired timer, no notification when timer still running
- All 152 tests passing (16 new + 136 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 2 - Task 4: Create a message listener to sync data between the popup and the background script
- Defined a typed message protocol in `src/background/index.ts`:
  - `MessageType` union type: `'GET_STATE' | 'START' | 'PAUSE' | 'RESET' | 'SET_MODE' | 'SET_DURATION'`
  - `TimerMessage` interface: `{ type: MessageType, payload?: { duration?: number, mode?: 'work' | 'break' } }`
  - `TimerMessageResponse` interface: `{ state: TimerStorageState }`
- Implemented `handleMessage()` async function to process popup commands:
  - `GET_STATE`: reads storage and recomputes `timeLeft` via `computeTimeLeft()` for accuracy (read-only, does not modify storage)
  - `START`: delegates to `startTimer()`, returns updated state
  - `PAUSE`: delegates to `pauseTimer()`, returns updated state
  - `RESET`: delegates to `resetTimer()`, supports optional custom duration via `payload.duration`
  - `SET_MODE`: updates `mode` field on current state, persists to storage
  - `SET_DURATION`: sets new `duration` and `timeLeft`, stops timer, clears alarm, persists to storage
  - Unknown message types: gracefully returns current state from storage
  - Always calls `sendResponse({ state })` exactly once per message
- Registered `chrome.runtime.onMessage.addListener` at module level:
  - Wrapper function calls `handleMessage()` and returns `true` to keep the message channel open for async `sendResponse`
- Added `chrome.runtime` mock to test setup (`mockRuntime.onMessage.addListener`)
- Wrote 35 new tests covering:
  - Module export: `handleMessage` function export
  - Listener registration: `chrome.runtime.onMessage.addListener` called, passes function, wrapper returns `true`
  - GET_STATE: default state, stored state, recomputes timeLeft for running timer, does not modify storage
  - START: starts timer, creates alarm, persists state
  - PAUSE: pauses running timer, clears alarm, preserves remaining time
  - RESET: resets to default duration, accepts custom duration payload, clears alarm
  - SET_MODE: changes to break/work, persists to storage, preserves other properties, defaults to current mode
  - SET_DURATION: sets new duration/timeLeft, stops timer, clears alarm, persists state, defaults to current duration
  - Unknown type: responds with current state
  - sendResponse contract: called exactly once for each message type, response always contains full state shape
- All 187 tests passing (35 new + 152 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 3 - Task 1: Define TypeScript interfaces for Task and TimerState
- Created `src/types/index.ts` with two exported interfaces:
  - `Task { id: string, text: string, completed: boolean, isSelected: boolean }`:
    - Represents a single task in the task list
    - `id`: unique identifier for the task
    - `text`: user-visible task description
    - `completed`: whether the task has been marked done
    - `isSelected`: whether this task is the "active" task shown above the timer
  - `TimerState { mode: 'work' | 'break', timeLeft: number, isRunning: boolean }`:
    - UI-facing timer state (lightweight projection of `TimerStorageState` from background script)
    - `mode`: current timer mode (work session or break)
    - `timeLeft`: seconds remaining on the countdown
    - `isRunning`: whether the timer is actively counting down
- Removed `.gitkeep` placeholder from `src/types/` (now has real content)
- Wrote 18 new tests in `src/test/types.test.ts` covering:
  - Task interface: id/text/completed/isSelected property types, completed task, selected task, key count validation (7 tests)
  - TimerState interface: mode property, work/break values, timeLeft type and zero edge case, isRunning type and true value, key count validation (8 tests)
  - Module exports: Task and TimerState compilation verification (2 tests)
  - Compatibility: TimerStorageState can be narrowed to TimerState (1 test)
- All 205 tests passing (18 new + 187 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 3 - Task 2: Create useChromeStorage custom React hook
- Hook already existed in `src/hooks/useChromeStorage.ts` (implemented in prior session)
- Fixed lint error: moved `valueRef.current = value` from render-time to a `useEffect` to comply with `react-hooks/refs` rule
- Hook provides generic two-way sync between React UI and `chrome.storage.local`:
  - Reads initial value from `chrome.storage.local.get(key)` on mount
  - Listens to `chrome.storage.onChanged` for external updates (e.g. from background script)
  - Provides `setValue` function that optimistically updates local state and persists to storage
  - Supports callback updater form `setValue(prev => newVal)` via `useRef` for latest value
  - Returns `[value, setValue, isLoading]` tuple
  - Cleans up listeners on unmount, cancels stale reads on key change
- Wrote 31 new tests in `src/test/useChromeStorage.test.ts` covering:
  - Module export (1 test)
  - Initial state: defaultValue, isLoading=true, return tuple shape (3 tests)
  - Reading from storage: calls get with key, updates on stored data, keeps default when undefined, sets isLoading false, objects, arrays, booleans, numbers (8 tests)
  - Writing to storage: calls set, optimistic update, callback updater, objects, arrays (5 tests)
  - External changes: registers onChanged listener, updates on external change, ignores other keys, ignores non-local areas, removes listener on unmount (5 tests)
  - Cleanup: cancels pending reads on unmount (1 test)
  - Key change: re-reads storage when key changes (1 test)
  - Return value stability: setValue reference stable across re-renders (1 test)
  - Edge cases: null, empty string, zero, false values from storage, sequential setValue, callback updater latest value (6 tests)
- All 236 tests passing (31 new + 205 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 5 - Task 1: Implement the Rest/Break popup dialog
- Created `src/components/RestBreakDialog.tsx` component using shadcn Dialog:
  - Appears automatically when the timer finishes (transitions from running to timeLeft=0)
  - Work mode finished: shows "Work session complete!" title, "Start Break" action button (5-minute break)
  - Break mode finished: shows "Break is over!" title, "Start Work" action button (25-minute work session)
  - Descriptive messages: work mode encourages taking a break, break mode encourages refocusing
  - Icon indicator: Coffee icon for work completion, BrainCircuit icon for break completion
  - "Dismiss" button to close the dialog without starting a new session
  - "Start Break"/"Start Work" action button switches mode, sets duration, and starts timer
  - Does NOT show on initial popup load if timer was already finished (only on live transitions)
- Added `switchModeAndStart(mode, duration)` to `src/hooks/useTimer.ts`:
  - Sequences SET_MODE, SET_DURATION, and START messages to background service worker
  - Atomically transitions between work and break sessions
- Added `justFinished` / `clearJustFinished` to `src/hooks/useTimer.ts`:
  - Detects running-to-finished transition via polling (avoids lint-violating setState in useEffect)
  - `justFinished` boolean flag set when polling detects `isRunning` went from true to false with `timeLeft <= 0`
  - `clearJustFinished()` resets the flag, called by UI on dismiss or action
  - `prevRunningRef` tracks previous running state to detect transitions
- Updated `src/components/TimerView.tsx` to integrate `RestBreakDialog`:
  - Passes `justFinished` as dialog open state
  - Passes `clearJustFinished` as dismiss handler
  - On action: clears finished flag and calls `switchModeAndStart`
- Wrote 32 new tests in `src/test/rest-break-dialog.test.tsx` covering:
  - useTimer Hook – switchModeAndStart (7 tests):
    - Export, message sequence (SET_MODE, SET_DURATION, START), SET_MODE payload, SET_DURATION payload, START message, state update, work mode switch
  - RestBreakDialog Component (14 tests):
    - Rendering: open/closed states, icon container, Dismiss button, action button
    - Work mode: title, description, "Start Break" label
    - Break mode: title, description, "Start Work" label
    - Interactions: dismiss callback, action callback with break mode (5min), action callback with work mode (25min)
  - TimerView Integration (11 tests):
    - Dialog appearance on timer finish (work mode), correct title for work/break completion
    - Dismiss closes dialog, action sends SET_MODE+SET_DURATION+START, action closes dialog
    - No dialog when running, no dialog when paused, no dialog on initial load with finished state
    - "Start Break"/"Start Work" button text for work/break mode completion
- All 412 tests passing (32 new + 380 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 5 - Task 2: Add "Active Task" display above the timer
- Updated `src/components/TimerView.tsx`:
  - Added `useChromeStorage<Task[]>('tasks', [])` to read tasks from storage (read-only)
  - Derives `activeTask` from the task with `isSelected: true`
  - Displays selected task name between the mode badge and countdown display
  - `truncate` + `max-w-[240px]` for long task names with `title` tooltip attribute
  - Conditionally rendered: only shows when a task is selected
- Updated `src/test/timer-view.test.tsx`:
  - Added `chrome.storage` mocks (local.get, local.set, onChanged) to support `useChromeStorage` in TimerView
  - Added storage cleanup to `resetState()` helper
  - Added `seedTasks()` and `makeTask()` test helpers
  - 9 new "Active Task Display" tests covering:
    - No display when no tasks, no selected task, or empty tasks array
    - Shows display when task is selected with correct text
    - Only shows the selected task when multiple tasks exist
    - Title attribute for tooltip on long names
    - Correct DOM ordering: mode badge -> active task -> countdown
    - Completed+selected task still displayed
- Fixed `src/test/rest-break-dialog.test.tsx`: added `chrome.storage` mocks (TimerView now uses `useChromeStorage`)
- Fixed `src/test/presets-section.test.tsx`: added `chrome.storage` mocks (TimerView now uses `useChromeStorage`)
- All 421 tests passing (9 new + 412 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 4 - Task 1: Timer View with countdown display, Progress bar, and control buttons
- Created `src/hooks/useTimer.ts` custom React hook for background communication:
  - `sendTimerMessage()`: typed wrapper around `chrome.runtime.sendMessage` returning `TimerStorageState`
  - Fetches initial state on mount via `GET_STATE` message to background service worker
  - Polls every 1 second while the timer is running to keep countdown display accurate
  - Exposes `start()`, `pause()`, `reset()` async actions that delegate to background script
  - `startPolling()` / `stopPolling()` manage the interval lifecycle
  - Properly cleans up interval on unmount to prevent memory leaks
  - Returns `{ state, isLoading, start, pause, reset }` tuple
- Created `src/components/TimerView.tsx` UI component:
  - Loading state: shows "Loading..." indicator while initial state is fetched
  - Mode badge: displays "Work" or "Break" label above the countdown
  - Countdown display: large centered MM:SS format with leading zeros and tabular-nums for stable layout
  - Progress bar: shadcn `Progress` component showing time remaining as percentage of total duration
  - Control buttons: Start (Play icon), Pause (Pause icon), Reset (RotateCcw icon) using shadcn `Button`
  - Start/Pause toggle: shows Start when idle, Pause when running
  - Disabled state: Start button disabled when timer reaches zero (prevents starting a finished timer)
  - Uses lucide-react icons (Play, Pause, RotateCcw) for button icons
- Updated `src/App.tsx` to integrate `TimerView` component into the main application layout
- Updated `src/test/App.test.tsx` to mock `chrome.runtime.sendMessage` for App tests (since App now renders TimerView)
- Wrote 38 new tests in `src/test/timer-view.test.tsx` covering:
  - useTimer Hook (13 tests):
    - Module export, GET_STATE on mount, state from background, isLoading lifecycle
    - START/PAUSE/RESET message sending and state updates
    - Polling cleanup on unmount, return shape validation
  - TimerView Component (25 tests):
    - Rendering: timer-view container, countdown display, mode label (work/break), progress bar, controls
    - Time formatting: leading zeros, single-digit minutes/seconds, zero display, large durations (50:00)
    - Button states: Start shown when idle, Pause shown when running, Start disabled at zero
    - Button interactions: START/PAUSE/RESET message sending on click, Start-to-Pause toggle, Pause-to-Start toggle
    - Button text labels: "Start", "Pause", "Reset"
    - Loading state: loading indicator shown before fetch, "Loading" text content
- All 274 tests passing (38 new + 236 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 4 - Task 2: Presets Section with clickable time presets and custom duration input
- Created `src/components/PresetsSection.tsx` component:
  - Three clickable preset buttons: 25m, 50m, 15m with Clock icons (lucide-react)
  - Active preset is visually highlighted (default variant vs outline variant based on currentDuration)
  - Custom duration input: number input with "Custom (min)" placeholder and "Set" button with Plus icon
  - Custom input supports Enter key submission for convenience
  - Validates custom input: rejects empty, zero, and negative values; floors decimal inputs
  - Clears custom input field after successful submission
  - All presets and custom input are disabled when timer is running (prevents mid-run duration changes)
  - Uses shadcn `Button` and `Input` components for consistent UI
- Added `setDuration` action to `src/hooks/useTimer.ts`:
  - Sends `SET_DURATION` message with `{ duration: durationSeconds }` payload to background service worker
  - Updates local state with response from background
  - Stops polling (since SET_DURATION stops the timer in the background)
- Integrated `PresetsSection` into `src/components/TimerView.tsx`:
  - Renders below the timer controls
  - Passes `currentDuration`, `isRunning`, and `onSetDuration` props from useTimer hook
- Wrote 35 new tests in `src/test/presets-section.test.tsx` covering:
  - useTimer Hook – setDuration (4 tests): export, SET_DURATION message with payload, state update, stops polling
  - PresetsSection Component (24 tests):
    - Rendering: section container, buttons container, three preset buttons, labels, custom section, input, submit button, "Set" text, placeholder, input type
    - Preset clicks: 25m/50m/15m each call onSetDuration with correct seconds value
    - Custom input: Set button submission, Enter key submission, clears input after submit, floors decimals
    - Validation: empty input rejected, zero rejected, negative rejected
    - Disabled state: preset buttons, custom input, submit button all disabled when running
    - Active highlighting: current preset visually distinct from others
  - TimerView integration (7 tests): renders presets section, renders preset buttons, renders custom input, sends SET_DURATION on preset click, updates countdown display, sends SET_DURATION for custom input, disables presets when running
- All 309 tests passing (35 new + 274 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 4 - Task 3: Task List with ScrollArea, Checkbox toggles, and Delete action
- Created `src/hooks/useTasks.ts` custom React hook for task CRUD operations:
  - Uses `useChromeStorage<Task[]>('tasks', [])` for persistence to `chrome.storage.local`
  - `addTask(text)`: creates a new Task with `Date.now()` ID, trims whitespace, rejects empty strings
  - `toggleTask(id)`: toggles `completed` boolean on a task by ID
  - `deleteTask(id)`: removes a task from the array by ID
  - `selectTask(id)`: marks a task as `isSelected` (active task for timer display), deselects all others; toggling an already-selected task deselects it
  - All operations persist immediately via `useChromeStorage` callback updater
  - Returns `{ tasks, isLoading, addTask, toggleTask, deleteTask, selectTask }`
- Created `src/components/TaskList.tsx` component:
  - Loading state: shows "Loading..." indicator while tasks are fetched from storage
  - Add task section: text input with "Add a task..." placeholder and "Add" button with Plus icon
  - Add task supports Enter key submission for convenience
  - Add button disabled when input is empty/whitespace
  - Clears input after successful task addition
  - Empty state: displays "No tasks yet. Add one above!" when task list is empty
  - Task items rendered inside shadcn `ScrollArea` (max-height 280px) for overflow handling
  - Each task item has:
    - shadcn `Checkbox` for toggling completed state
    - Clickable task text for selecting as active task (with truncation for long text)
    - Completed tasks show `line-through` and `text-muted-foreground` styling
    - Selected tasks show `font-medium` text and `bg-muted/70` + `ring-primary/30` highlight on the row
    - Delete button (Trash2 icon) with ghost variant, appears on hover via `group-hover:opacity-100`
    - Delete button uses `text-destructive` color for visual clarity
  - Uses `data-testid` attributes on every significant DOM element for testing
- Wrote 52 new tests in `src/test/task-list.test.tsx` covering:
  - useTasks Hook (22 tests):
    - Module export, initial empty state, isLoading lifecycle, loads from storage, CRUD function types
    - addTask: appends task, sets completed/isSelected to false, generates string ID, trims whitespace, rejects empty/whitespace, persists to storage
    - toggleTask: marks completed, unmarks completed, preserves other tasks
    - deleteTask: removes by ID, persists removal
    - selectTask: selects task, deselects on re-click, deselects others when selecting one
  - TaskList Component (30 tests):
    - Loading state: loading indicator shown, "Loading" text
    - Empty state: renders container, empty message, add input, placeholder, add button, "Add" text, scroll area, button disabled when empty
    - With tasks: renders task items from storage, task text, checkbox, delete button, no empty state
    - Adding: adds on button click, adds on Enter key, clears input, rejects whitespace, removes empty state
    - Toggling: checkbox toggles completion, completed shows line-through, incomplete no line-through
    - Deleting: delete removes task, shows empty state after last delete
    - Selecting: click selects, re-click deselects, selected has highlight, non-selected no highlight
    - Multiple tasks: renders many tasks, deleting one preserves others
- All 361 tests passing (52 new + 309 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 4 - Task 4: Tabs layout to switch between Focus and Tasks views
- Updated `src/App.tsx` to wrap TimerView and TaskList in a shadcn `Tabs` component:
  - Imported `Tabs`, `TabsList`, `TabsTrigger`, `TabsContent` from `@/components/ui/tabs`
  - Imported `TaskList` from `./components/TaskList`
  - Added `Timer` and `ListTodo` lucide-react icons for tab triggers
  - Two tabs: "Focus" (default active) containing `<TimerView />`, and "Tasks" containing `<TaskList />`
  - `defaultValue="focus"` ensures the timer view is shown on popup open
  - Added `data-testid` attributes to tabs-list, tab-focus, tab-tasks, tab-content-focus, tab-content-tasks
  - Full-width tabs list with flex-1 triggers for equal sizing
  - Added `mb-2` to tagline for spacing between header and tabs
- Updated `src/test/App.test.tsx` with comprehensive Tabs layout tests:
  - Extended chrome mock to include `chrome.storage` (local.get, local.set, onChanged) for TaskList/useChromeStorage compatibility
  - Installed `@testing-library/user-event` for Radix UI tab interaction testing (fireEvent.click doesn't trigger Radix pointer events)
  - 19 new tests covering:
    - Tab rendering: tabs list, Focus trigger, Tasks trigger, text labels
    - Default state: Focus tab active, Tasks tab inactive, Focus content panel visible, TimerView rendered, TaskList not rendered
    - Tab switching: clicking Tasks activates it, deactivates Focus, renders TaskList, hides TimerView
    - Round-trip: switching to Tasks and back to Focus restores TimerView
    - Tasks tab content panel rendered when active
    - Both triggers always rendered regardless of active tab
    - TaskList empty state visible in Tasks tab
    - Timer countdown (25:00) visible in Focus tab by default
- All 380 tests passing (19 new + 361 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)

## 2026-02-15: Phase 5 - Task 3: Configure vite.config.ts for multi-page build
- Updated `vite.config.ts` with `build.rollupOptions` for multi-page Chrome Extension output:
  - `input`: two entry points:
    - `popup`: `index.html` (the popup UI with React app)
    - `background`: `src/background/index.ts` (the service worker with timer logic)
  - `output.entryFileNames`: custom function that routes the `background` chunk to `background.js` at the dist root, and all other entries to `assets/[name]-[hash].js`
- Build output structure in `dist/`:
  - `index.html` - popup HTML page with `<script type="module">` referencing bundled popup JS
  - `background.js` - standalone background service worker bundle (no React, no DOM)
  - `assets/popup-[hash].js` - bundled popup React application
  - `assets/popup-[hash].css` - bundled popup styles (Tailwind CSS)
  - `manifest.json` - copied from `public/`, references `index.html` and `background.js` correctly
  - `icons/` - extension icons copied from `public/icons/`
- Background service worker is built as a standalone bundle:
  - Contains only timer logic, chrome.alarms, chrome.storage, chrome.runtime, chrome.notifications
  - Does NOT include React, ReactDOM, or any UI code
  - Minified and self-contained for Chrome Extension service worker context
- Verified `dist/manifest.json` references align with build output:
  - `action.default_popup: "index.html"` -> `dist/index.html` exists
  - `background.service_worker: "background.js"` -> `dist/background.js` exists
  - `icons` -> `dist/icons/icon-{16,48,128}.png` exist
- Wrote 34 new tests in `src/test/vite-build.test.ts` covering:
  - vite.config.ts structure (9 tests): file exists, rollupOptions/input defined, popup entry, background entry, input keys, entryFileNames config, background.js routing, assets routing
  - Build output - popup (5 tests): index.html exists, script tag, JS reference, CSS reference, root div
  - Build output - background (6 tests): background.js exists, not empty, contains timer logic, chrome.alarms, chrome.storage, chrome.runtime, no React imports
  - Build output - assets (4 tests): assets/ exists, JS files, CSS files, hashed names
  - Build output - static assets (5 tests): manifest.json copied, popup reference, service worker reference, icons directory, icon files
  - Build output - loadable extension (3 tests): all manifest references exist, no unexpected HTML files, background.js at root not in assets/
  - Tests use `it.skipIf(!distExists)` for graceful handling when dist/ is absent
- All 455 tests passing (34 new + 421 existing)
- Linting passes cleanly (0 errors, 2 pre-existing warnings from shadcn components)